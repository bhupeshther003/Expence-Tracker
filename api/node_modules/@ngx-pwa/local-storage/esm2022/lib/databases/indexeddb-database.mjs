import { Injectable, inject } from "@angular/core";
import { ReplaySubject, fromEvent, of, race, throwError } from "rxjs";
import { first, map, mergeMap, takeWhile, tap } from "rxjs/operators";
import { IDB_DB_NAME, IDB_DB_VERSION, IDB_NO_WRAP, IDB_STORE_NAME } from "../tokens";
import { IDBBrokenError } from "./exceptions";
import * as i0 from "@angular/core";
export class IndexedDBDatabase {
    constructor() {
        /**
         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection
         * even after the connection success event happened
         */
        this.database = new ReplaySubject(1);
        /**
         * Index used when wrapping value. *For backward compatibility only.*
         */
        this.wrapIndex = "value";
        this.dbName = inject(IDB_DB_NAME);
        this.storeName = inject(IDB_STORE_NAME);
        this.dbVersion = inject(IDB_DB_VERSION);
        this.noWrap = inject(IDB_NO_WRAP);
        /* Connect to `indexedDB`, with prefix if provided by the user */
        this.connect();
    }
    /**
     * Information about `indexedDB` connection. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version
     */
    get backingStore() {
        return {
            database: this.dbName,
            store: this.storeName,
            version: this.dbVersion,
        };
    }
    /**
     * Number of items in our `indexedDB` database and object store
     */
    get size() {
        /* Open a transaction in read-only mode */
        return this.transaction("readonly").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Request to know the number of items */
            const request = store.count();
            /* Return the result */
            return events.pipe(map(() => request.result));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Gets an item value in our `indexedDB` store
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`
     */
    get(key) {
        /* Open a transaction in read-only mode */
        return this.transaction("readonly").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Request the value with the key provided by the user */
            const request = store.get(key);
            /* Listen events and return the result */
            return events.pipe(map(() => {
                if ((request.result !== undefined) && (request.result !== null)) {
                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */
                    if (!this.noWrap && (typeof request.result === "object") && (this.wrapIndex in request.result) &&
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        return request.result[this.wrapIndex];
                    }
                    else {
                        /* Cast to the wanted type */
                        return request.result;
                    }
                }
                /* Return `undefined` if the value is empty */
                return undefined;
            }));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Sets an item in our `indexedDB` store
     * @param key The item's key
     * @param data The item's value
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    set(key, data) {
        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */
        if (data === undefined) {
            return this.delete(key);
        }
        /* Open a transaction in write mode */
        return this.transaction("readwrite").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Prior to v8, data was wrapped in a `{ value: ... }` object */
            const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };
            /* Add if the item is not existing yet, or update otherwise */
            store.put(dataToStore, key);
            /* Listen to events and return `undefined` as no value is expected */
            return events.pipe(map(() => undefined));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes an item in our `indexedDB` store
     * @param key The item's key
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    delete(key) {
        /* Open a transaction in write mode */
        return this.transaction("readwrite").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Delete the item in store */
            store.delete(key);
            /* Listen to events and return `undefined` as no data is expected here */
            return events.pipe(map(() => undefined));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes all items from our `indexedDB` objet store
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    clear() {
        /* Open a transaction in write mode */
        return this.transaction("readwrite").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Delete all items in object store */
            store.clear();
            /* Listen to events and return `undefined` as no data is expected here */
            return events.pipe(map(() => undefined));
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Get all the keys in our `indexedDB` store
     * @returns An RxJS `Observable` iterating on each key
     */
    keys() {
        /* Open a transaction in read-only mode */
        return this.transaction("readonly").pipe(
        /* `first()` is used as the final operator in other methods to complete the `Observable`
         * (as it all starts from a `ReplaySubject` which never ends),
         * but as this method is iterating over multiple values, `first()` **must** be used here */
        first(), mergeMap((transactionData) => {
            const { store } = transactionData;
            /* Open a cursor on the store
             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */
            const request = store.openKeyCursor();
            /* Listen to success event */
            const success$ = fromEvent(request, "success").pipe(
            /* Stop the `Observable` when the cursor is `null` */
            takeWhile(() => (request.result !== null)), 
            /* This lib only allows string keys, but user could have added other types of keys from outside
             * It's OK to cast as the cursor as been tested in the previous operator */
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-base-to-string
            map(() => request.result.key.toString()), 
            /* Iterate on the cursor */
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            tap(() => { request.result.continue(); }));
            /* Listen to error event and if so, throw an error */
            const error$ = this.listenError(request);
            /* Choose the first event to occur */
            return race([success$, error$]);
        }));
    }
    /**
     * Check if a key exists in our `indexedDB` store
     * @returns An RxJS `Observable` telling if the key exists or not
     */
    has(key) {
        /* Open a transaction in read-only mode */
        return this.transaction("readonly").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Check if the key exists in the store
             * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69
             */
            const request = store.getKey(key);
            /* Listen to events and return `true` or `false` */
            return events.pipe(map(() => (request.result !== undefined) ? true : false));
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Connects to `indexedDB` and creates the object store on first time
     */
    connect() {
        let request;
        /* Connect to `indexedDB`
         * Will fail in Safari cross-origin iframes
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */
        try {
            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */
            request = indexedDB.open(this.dbName, this.dbVersion);
        }
        catch {
            this.database.error(new IDBBrokenError());
            return;
        }
        /* Create store on first connection */
        this.createStore(request);
        /* Listen to success and error events */
        const success$ = fromEvent(request, "success");
        const error$ = this.listenError(request);
        /* Choose the first to occur */
        race([success$, error$])
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Register the database connection in the `ReplaySubject` for further access */
                this.database.next(request.result);
            },
            error: () => {
                /* Firefox private mode issue: fallback storage if IndexedDb connection is failing
                * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}
                * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */
                this.database.error(new IDBBrokenError());
            },
        });
    }
    /**
     * Create store on first use of `indexedDB`
     * @param request `indexedDB` database opening request
     */
    createStore(request) {
        /* Listen to the event fired on first connection */
        fromEvent(request, "upgradeneeded")
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Check if the store already exists, to avoid error */
                if (!request.result.objectStoreNames.contains(this.storeName)) {
                    /* Create the object store */
                    request.result.createObjectStore(this.storeName);
                }
            }
        });
    }
    /**
     * Open an `indexedDB` transaction and get our store
     * @param mode `readonly` or `readwrite`
     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`
     */
    transaction(mode) {
        /* From the `indexedDB` connection, open a transaction and get the store */
        return this.database
            .pipe(mergeMap((database) => {
            let transaction;
            try {
                transaction = database.transaction([this.storeName], mode);
            }
            catch (error) {
                /* The store could have been deleted from outside */
                return throwError(() => error);
            }
            /* Get the store from the transaction */
            const store = transaction.objectStore(this.storeName);
            /* Listen transaction `complete` and `error` events */
            const events = this.listenTransactionEvents(transaction);
            return of({ store, events });
        }));
    }
    /**
     * Listen errors on a transaction or request, and throw if trigerred
     * @param transactionOrRequest `indexedDb` transaction or request to listen
     * @returns An `Observable` listening to errors
     */
    listenError(transactionOrRequest) {
        return fromEvent(transactionOrRequest, "error").pipe(
        /* Throw on error to be able to catch errors in RxJS way.
         * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`
         * if we are on the request and the error is only triggered later by the transaction */
        mergeMap((event) => throwError(() => event.target?.error)));
    }
    /**
     * Listen transaction `complete` and `error` events
     * @param transaction Transaction to listen
     * @returns An `Observable` listening to transaction `complete` and `error` events
     */
    listenTransactionEvents(transaction) {
        /* Listen to the `complete` event */
        const complete$ = fromEvent(transaction, "complete");
        /* Listen to the `error` event */
        const error$ = this.listenError(transaction);
        /* Choose the first event to occur */
        return race([complete$, error$]);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: IndexedDBDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: IndexedDBDatabase, providedIn: "root" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: IndexedDBDatabase, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: "root"
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXB3YS9sb2NhbC1zdG9yYWdlL3NyYy9saWIvZGF0YWJhc2VzL2luZGV4ZWRkYi1kYXRhYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQWMsYUFBYSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRixPQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDckYsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7QUFNOUMsTUFBTSxPQUFPLGlCQUFpQjtJQWlDNUI7UUFoQkE7OztXQUdHO1FBQ2dCLGFBQVEsR0FBRyxJQUFJLGFBQWEsQ0FBYyxDQUFDLENBQUMsQ0FBQztRQU9oRTs7V0FFRztRQUNnQixjQUFTLEdBQUcsT0FBTyxDQUFDO1FBSXJDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRWxDLGlFQUFpRTtRQUNqRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFFakIsQ0FBQztJ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LElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFN0MscUNBQXFDO1FBQ3JDLE9BQU8sSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFFbkMsQ0FBQzs4R0FwYlUsaUJBQWlCO2tIQUFqQixpQkFBaUIsY0FGaEIsTUFBTTs7MkZBRVAsaUJBQWlCO2tCQUg3QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIGluamVjdCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0LCBmcm9tRXZlbnQsIG9mLCByYWNlLCB0aHJvd0Vycm9yIH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IGZpcnN0LCBtYXAsIG1lcmdlTWFwLCB0YWtlV2hpbGUsIHRhcCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuaW1wb3J0IHsgSURCX0RCX05BTUUsIElEQl9EQl9WRVJTSU9OLCBJREJfTk9fV1JBUCwgSURCX1NUT1JFX05BTUUgfSBmcm9tIFwiLi4vdG9rZW5zXCI7XG5pbXBvcnQgeyBJREJCcm9rZW5FcnJvciB9IGZyb20gXCIuL2V4Y2VwdGlvbnNcIjtcbmltcG9ydCB7IExvY2FsRGF0YWJhc2UgfSBmcm9tIFwiLi9sb2NhbC1kYXRhYmFzZVwiO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46IFwicm9vdFwiXG59KVxuZXhwb3J0IGNsYXNzIEluZGV4ZWREQkRhdGFiYXNlIGltcGxlbWVudHMgTG9jYWxEYXRhYmFzZSB7XG5cbiAgLyoqXG4gICAqIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWVcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBkYk5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgb2JqZWN0IHN0b3JlIG5hbWVcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBzdG9yZU5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgZGF0YWJhc2UgdmVyc2lvbi4gTXVzdCBiZSBhbiB1bnNpZ25lZCAqKmludGVnZXIqKlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRiVmVyc2lvbjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBkYXRhYmFzZSBjb25uZWN0aW9uLCB3cmFwcGVkIGluIGEgUnhKUyBgUmVwbGF5U3ViamVjdGAgdG8gYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGNvbm5lY3Rpb25cbiAgICogZXZlbiBhZnRlciB0aGUgY29ubmVjdGlvbiBzdWNjZXNzIGV2ZW50IGhhcHBlbmVkXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGF0YWJhc2UgPSBuZXcgUmVwbGF5U3ViamVjdDxJREJEYXRhYmFzZT4oMSk7XG5cbiAgLyoqXG4gICAqIEZsYWcgdG8gbm90IHdyYXAgYGluZGV4ZWREQmAgdmFsdWVzIGZvciBpbnRlcm9wZXJhYmlsaXR5IG9yIHRvIHdyYXAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgbm9XcmFwOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbmRleCB1c2VkIHdoZW4gd3JhcHBpbmcgdmFsdWUuICpGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbmx5LipcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSB3cmFwSW5kZXggPSBcInZhbHVlXCI7XG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB0aGlzLmRiTmFtZSA9IGluamVjdChJREJfREJfTkFNRSk7XG4gICAgdGhpcy5zdG9yZU5hbWUgPSBpbmplY3QoSURCX1NUT1JFX05BTUUpO1xuICAgIHRoaXMuZGJWZXJzaW9uID0gaW5qZWN0KElEQl9EQl9WRVJTSU9OKTtcbiAgICB0aGlzLm5vV3JhcCA9IGluamVjdChJREJfTk9fV1JBUCk7XG5cbiAgICAvKiBDb25uZWN0IHRvIGBpbmRleGVkREJgLCB3aXRoIHByZWZpeCBpZiBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gIH1cblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgYGluZGV4ZWREQmAgY29ubmVjdGlvbi4gKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogQHJldHVybnMgYGluZGV4ZWREQmAgZGF0YWJhc2UgbmFtZSwgc3RvcmUgbmFtZSBhbmQgZGF0YWJhc2UgdmVyc2lvblxuICAgKi9cbiAgZ2V0IGJhY2tpbmdTdG9yZSgpOiB7IGRhdGFiYXNlOiBzdHJpbmcsIHN0b3JlOiBzdHJpbmcsIHZlcnNpb246IG51bWJlcjsgfSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YWJhc2U6IHRoaXMuZGJOYW1lLFxuICAgICAgc3RvcmU6IHRoaXMuc3RvcmVOYW1lLFxuICAgICAgdmVyc2lvbjogdGhpcy5kYlZlcnNpb24sXG4gICAgfTtcblxuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBpdGVtcyBpbiBvdXIgYGluZGV4ZWREQmAgZGF0YWJhc2UgYW5kIG9iamVjdCBzdG9yZVxuICAgKi9cbiAgZ2V0IHNpemUoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiByZWFkLW9ubHkgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKFwicmVhZG9ubHlcIikucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBSZXF1ZXN0IHRvIGtub3cgdGhlIG51bWJlciBvZiBpdGVtcyAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuY291bnQoKTtcblxuICAgICAgICAvKiBSZXR1cm4gdGhlIHJlc3VsdCAqL1xuICAgICAgICByZXR1cm4gZXZlbnRzLnBpcGUobWFwKCgpID0+IHJlcXVlc3QucmVzdWx0KSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSBhZnRlciB0aGUgZmlyc3QgdmFsdWUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gaXRlbSB2YWx1ZSBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSdzIHZhbHVlIGlmIHRoZSBrZXkgZXhpc3RzLCBgdW5kZWZpbmVkYCBvdGhlcndpc2UsIHdyYXBwZWQgaW4gYW4gUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICovXG4gIGdldChrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5rbm93bj4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oXCJyZWFkb25seVwiKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uRGF0YSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RvcmUsIGV2ZW50cyB9ID0gdHJhbnNhY3Rpb25EYXRhO1xuXG4gICAgICAgIC8qIFJlcXVlc3QgdGhlIHZhbHVlIHdpdGggdGhlIGtleSBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KGtleSk7XG5cbiAgICAgICAgLyogTGlzdGVuIGV2ZW50cyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcCgoKTogdW5rbm93biA9PiB7XG5cbiAgICAgICAgICBpZiAoKHJlcXVlc3QucmVzdWx0ICE9PSB1bmRlZmluZWQpICYmIChyZXF1ZXN0LnJlc3VsdCAhPT0gbnVsbCkpIHtcblxuICAgICAgICAgICAgLyogUHJpb3IgdG8gdjgsIHRoZSB2YWx1ZSB3YXMgd3JhcHBlZCBpbiBhbiBgeyB2YWx1ZTogLi4ufWAgb2JqZWN0ICovXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9XcmFwICYmICh0eXBlb2YgcmVxdWVzdC5yZXN1bHQgPT09IFwib2JqZWN0XCIpICYmICh0aGlzLndyYXBJbmRleCBpbiByZXF1ZXN0LnJlc3VsdCkgJiZcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAocmVxdWVzdC5yZXN1bHRbdGhpcy53cmFwSW5kZXhdICE9PSB1bmRlZmluZWQpICYmIChyZXF1ZXN0LnJlc3VsdFt0aGlzLndyYXBJbmRleF0gIT09IG51bGwpKSB7XG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5yZXN1bHRbdGhpcy53cmFwSW5kZXhdO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIC8qIENhc3QgdG8gdGhlIHdhbnRlZCB0eXBlICovXG4gICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LnJlc3VsdDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogUmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eSAqL1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgfSkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGl0ZW0gaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIGRhdGEgVGhlIGl0ZW0ncyB2YWx1ZVxuICAgKiBAcmV0dXJucyBBbiBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgc2V0KGtleTogc3RyaW5nLCBkYXRhOiB1bmtub3duKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIC8qIFN0b3JpbmcgYHVuZGVmaW5lZGAgaW4gYGluZGV4ZWREYmAgY2FuIGNhdXNlIGlzc3VlcyBpbiBzb21lIGJyb3dzZXJzIHNvIHJlbW92aW5nIGl0ZW0gaW5zdGVhZCAqL1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiB3cml0ZSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oXCJyZWFkd3JpdGVcIikucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBQcmlvciB0byB2OCwgZGF0YSB3YXMgd3JhcHBlZCBpbiBhIGB7IHZhbHVlOiAuLi4gfWAgb2JqZWN0ICovXG4gICAgICAgIGNvbnN0IGRhdGFUb1N0b3JlID0gdGhpcy5ub1dyYXAgPyBkYXRhIDogeyBbdGhpcy53cmFwSW5kZXhdOiBkYXRhIH07XG5cbiAgICAgICAgLyogQWRkIGlmIHRoZSBpdGVtIGlzIG5vdCBleGlzdGluZyB5ZXQsIG9yIHVwZGF0ZSBvdGhlcndpc2UgKi9cbiAgICAgICAgc3RvcmUucHV0KGRhdGFUb1N0b3JlLCBrZXkpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBldmVudHMgYW5kIHJldHVybiBgdW5kZWZpbmVkYCBhcyBubyB2YWx1ZSBpcyBleHBlY3RlZCAqL1xuICAgICAgICByZXR1cm4gZXZlbnRzLnBpcGUobWFwKCgpID0+IHVuZGVmaW5lZCkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGl0ZW0gaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKFwicmVhZHdyaXRlXCIpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb25EYXRhKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdG9yZSwgZXZlbnRzIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogRGVsZXRlIHRoZSBpdGVtIGluIHN0b3JlICovXG4gICAgICAgIHN0b3JlLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBldmVudHMgYW5kIHJldHVybiBgdW5kZWZpbmVkYCBhcyBubyBkYXRhIGlzIGV4cGVjdGVkIGhlcmUgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcCgoKSA9PiB1bmRlZmluZWQpKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgaXRlbXMgZnJvbSBvdXIgYGluZGV4ZWREQmAgb2JqZXQgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGNsZWFyKCk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKFwicmVhZHdyaXRlXCIpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb25EYXRhKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdG9yZSwgZXZlbnRzIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogRGVsZXRlIGFsbCBpdGVtcyBpbiBvYmplY3Qgc3RvcmUgKi9cbiAgICAgICAgc3RvcmUuY2xlYXIoKTtcblxuICAgICAgICAvKiBMaXN0ZW4gdG8gZXZlbnRzIGFuZCByZXR1cm4gYHVuZGVmaW5lZGAgYXMgbm8gZGF0YSBpcyBleHBlY3RlZCBoZXJlICovXG4gICAgICAgIHJldHVybiBldmVudHMucGlwZShtYXAoKCkgPT4gdW5kZWZpbmVkKSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUga2V5cyBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgaXRlcmF0aW5nIG9uIGVhY2gga2V5XG4gICAqL1xuICBrZXlzKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gcmVhZC1vbmx5IG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbihcInJlYWRvbmx5XCIpLnBpcGUoXG4gICAgICAvKiBgZmlyc3QoKWAgaXMgdXNlZCBhcyB0aGUgZmluYWwgb3BlcmF0b3IgaW4gb3RoZXIgbWV0aG9kcyB0byBjb21wbGV0ZSB0aGUgYE9ic2VydmFibGVgXG4gICAgICAgKiAoYXMgaXQgYWxsIHN0YXJ0cyBmcm9tIGEgYFJlcGxheVN1YmplY3RgIHdoaWNoIG5ldmVyIGVuZHMpLFxuICAgICAgICogYnV0IGFzIHRoaXMgbWV0aG9kIGlzIGl0ZXJhdGluZyBvdmVyIG11bHRpcGxlIHZhbHVlcywgYGZpcnN0KClgICoqbXVzdCoqIGJlIHVzZWQgaGVyZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogT3BlbiBhIGN1cnNvciBvbiB0aGUgc3RvcmVcbiAgICAgICAgICogQXZvaWQgaXNzdWVzIGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNjkgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLm9wZW5LZXlDdXJzb3IoKTtcblxuICAgICAgICAvKiBMaXN0ZW4gdG8gc3VjY2VzcyBldmVudCAqL1xuICAgICAgICBjb25zdCBzdWNjZXNzJCA9IGZyb21FdmVudChyZXF1ZXN0LCBcInN1Y2Nlc3NcIikucGlwZShcbiAgICAgICAgICAvKiBTdG9wIHRoZSBgT2JzZXJ2YWJsZWAgd2hlbiB0aGUgY3Vyc29yIGlzIGBudWxsYCAqL1xuICAgICAgICAgIHRha2VXaGlsZSgoKSA9PiAocmVxdWVzdC5yZXN1bHQgIT09IG51bGwpKSxcbiAgICAgICAgICAvKiBUaGlzIGxpYiBvbmx5IGFsbG93cyBzdHJpbmcga2V5cywgYnV0IHVzZXIgY291bGQgaGF2ZSBhZGRlZCBvdGhlciB0eXBlcyBvZiBrZXlzIGZyb20gb3V0c2lkZVxuICAgICAgICAgICAqIEl0J3MgT0sgdG8gY2FzdCBhcyB0aGUgY3Vyc29yIGFzIGJlZW4gdGVzdGVkIGluIHRoZSBwcmV2aW91cyBvcGVyYXRvciAqL1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICAgICAgICBtYXAoKCkgPT4gcmVxdWVzdC5yZXN1bHQhLmtleS50b1N0cmluZygpKSxcbiAgICAgICAgICAvKiBJdGVyYXRlIG9uIHRoZSBjdXJzb3IgKi9cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgIHRhcCgoKSA9PiB7IHJlcXVlc3QucmVzdWx0IS5jb250aW51ZSgpOyB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICAvKiBMaXN0ZW4gdG8gZXJyb3IgZXZlbnQgYW5kIGlmIHNvLCB0aHJvdyBhbiBlcnJvciAqL1xuICAgICAgICBjb25zdCBlcnJvciQgPSB0aGlzLmxpc3RlbkVycm9yKHJlcXVlc3QpO1xuXG4gICAgICAgIC8qIENob29zZSB0aGUgZmlyc3QgZXZlbnQgdG8gb2NjdXIgKi9cbiAgICAgICAgcmV0dXJuIHJhY2UoW3N1Y2Nlc3MkLCBlcnJvciRdKTtcblxuICAgICAgfSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2V5IGV4aXN0cyBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdGVsbGluZyBpZiB0aGUga2V5IGV4aXN0cyBvciBub3RcbiAgICovXG4gIGhhcyhrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oXCJyZWFkb25seVwiKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uRGF0YSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RvcmUsIGV2ZW50cyB9ID0gdHJhbnNhY3Rpb25EYXRhO1xuXG4gICAgICAgIC8qIENoZWNrIGlmIHRoZSBrZXkgZXhpc3RzIGluIHRoZSBzdG9yZVxuICAgICAgICAgKiBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2lzc3Vlcy82OVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldEtleShrZXkpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBldmVudHMgYW5kIHJldHVybiBgdHJ1ZWAgb3IgYGZhbHNlYCAqL1xuICAgICAgICByZXR1cm4gZXZlbnRzLnBpcGUobWFwKCgpID0+IChyZXF1ZXN0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSA/IHRydWUgOiBmYWxzZSkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIGBpbmRleGVkREJgIGFuZCBjcmVhdGVzIHRoZSBvYmplY3Qgc3RvcmUgb24gZmlyc3QgdGltZVxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbm5lY3QoKTogdm9pZCB7XG5cbiAgICBsZXQgcmVxdWVzdDogSURCT3BlbkRCUmVxdWVzdDtcblxuICAgIC8qIENvbm5lY3QgdG8gYGluZGV4ZWREQmBcbiAgICAgKiBXaWxsIGZhaWwgaW4gU2FmYXJpIGNyb3NzLW9yaWdpbiBpZnJhbWVzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNDJ9ICovXG4gICAgdHJ5IHtcblxuICAgICAgLyogRG8gTk9UIGV4cGxpY2l0IGB3aW5kb3dgIGhlcmUsIGFzIGBpbmRleGVkREJgIGNvdWxkIGJlIHVzZWQgZnJvbSBhIHdlYiB3b3JrZXIgdG9vICovXG4gICAgICByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUsIHRoaXMuZGJWZXJzaW9uKTtcblxuICAgIH0gY2F0Y2gge1xuXG4gICAgICB0aGlzLmRhdGFiYXNlLmVycm9yKG5ldyBJREJCcm9rZW5FcnJvcigpKTtcblxuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgLyogQ3JlYXRlIHN0b3JlIG9uIGZpcnN0IGNvbm5lY3Rpb24gKi9cbiAgICB0aGlzLmNyZWF0ZVN0b3JlKHJlcXVlc3QpO1xuXG4gICAgLyogTGlzdGVuIHRvIHN1Y2Nlc3MgYW5kIGVycm9yIGV2ZW50cyAqL1xuICAgIGNvbnN0IHN1Y2Nlc3MkID0gZnJvbUV2ZW50KHJlcXVlc3QsIFwic3VjY2Vzc1wiKTtcbiAgICBjb25zdCBlcnJvciQgPSB0aGlzLmxpc3RlbkVycm9yKHJlcXVlc3QpO1xuXG4gICAgLyogQ2hvb3NlIHRoZSBmaXJzdCB0byBvY2N1ciAqL1xuICAgIHJhY2UoW3N1Y2Nlc3MkLCBlcnJvciRdKVxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgLyogUmVnaXN0ZXIgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gaW4gdGhlIGBSZXBsYXlTdWJqZWN0YCBmb3IgZnVydGhlciBhY2Nlc3MgKi9cbiAgICAgICAgICB0aGlzLmRhdGFiYXNlLm5leHQocmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKCkgPT4ge1xuICAgICAgICAgIC8qIEZpcmVmb3ggcHJpdmF0ZSBtb2RlIGlzc3VlOiBmYWxsYmFjayBzdG9yYWdlIGlmIEluZGV4ZWREYiBjb25uZWN0aW9uIGlzIGZhaWxpbmdcbiAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc4MTk4Mn1cbiAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzI2fSAqL1xuICAgICAgICAgIHRoaXMuZGF0YWJhc2UuZXJyb3IobmV3IElEQkJyb2tlbkVycm9yKCkpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgc3RvcmUgb24gZmlyc3QgdXNlIG9mIGBpbmRleGVkREJgXG4gICAqIEBwYXJhbSByZXF1ZXN0IGBpbmRleGVkREJgIGRhdGFiYXNlIG9wZW5pbmcgcmVxdWVzdFxuICAgKi9cbiAgcHJvdGVjdGVkIGNyZWF0ZVN0b3JlKHJlcXVlc3Q6IElEQk9wZW5EQlJlcXVlc3QpOiB2b2lkIHtcblxuICAgIC8qIExpc3RlbiB0byB0aGUgZXZlbnQgZmlyZWQgb24gZmlyc3QgY29ubmVjdGlvbiAqL1xuICAgIGZyb21FdmVudChyZXF1ZXN0LCBcInVwZ3JhZGVuZWVkZWRcIilcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgKi9cbiAgICAgIC5waXBlKGZpcnN0KCkpXG4gICAgICAuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuXG4gICAgICAgICAgLyogQ2hlY2sgaWYgdGhlIHN0b3JlIGFscmVhZHkgZXhpc3RzLCB0byBhdm9pZCBlcnJvciAqL1xuICAgICAgICAgIGlmICghcmVxdWVzdC5yZXN1bHQub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0aGlzLnN0b3JlTmFtZSkpIHtcblxuICAgICAgICAgICAgLyogQ3JlYXRlIHRoZSBvYmplY3Qgc3RvcmUgKi9cbiAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNyZWF0ZU9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gYW4gYGluZGV4ZWREQmAgdHJhbnNhY3Rpb24gYW5kIGdldCBvdXIgc3RvcmVcbiAgICogQHBhcmFtIG1vZGUgYHJlYWRvbmx5YCBvciBgcmVhZHdyaXRlYFxuICAgKiBAcmV0dXJucyBBbiBgaW5kZXhlZERCYCB0cmFuc2FjdGlvbiBzdG9yZSBhbmQgZXZlbnRzLCB3cmFwcGVkIGluIGFuIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqL1xuICBwcm90ZWN0ZWQgdHJhbnNhY3Rpb24obW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlKTogT2JzZXJ2YWJsZTx7XG4gICAgc3RvcmU6IElEQk9iamVjdFN0b3JlO1xuICAgIGV2ZW50czogT2JzZXJ2YWJsZTxFdmVudD47XG4gIH0+IHtcblxuICAgIC8qIEZyb20gdGhlIGBpbmRleGVkREJgIGNvbm5lY3Rpb24sIG9wZW4gYSB0cmFuc2FjdGlvbiBhbmQgZ2V0IHRoZSBzdG9yZSAqL1xuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlXG4gICAgICAucGlwZShtZXJnZU1hcCgoZGF0YWJhc2UpID0+IHtcblxuICAgICAgICBsZXQgdHJhbnNhY3Rpb246IElEQlRyYW5zYWN0aW9uO1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IGRhdGFiYXNlLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIG1vZGUpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cbiAgICAgICAgICAvKiBUaGUgc3RvcmUgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgZnJvbSBvdXRzaWRlICovXG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoKCkgPT4gZXJyb3IgYXMgRE9NRXhjZXB0aW9uKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLyogR2V0IHRoZSBzdG9yZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiAqL1xuICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcblxuICAgICAgICAvKiBMaXN0ZW4gdHJhbnNhY3Rpb24gYGNvbXBsZXRlYCBhbmQgYGVycm9yYCBldmVudHMgKi9cbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5saXN0ZW5UcmFuc2FjdGlvbkV2ZW50cyh0cmFuc2FjdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIG9mKHsgc3RvcmUsIGV2ZW50cyB9KTtcblxuICAgICAgfSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIGVycm9ycyBvbiBhIHRyYW5zYWN0aW9uIG9yIHJlcXVlc3QsIGFuZCB0aHJvdyBpZiB0cmlnZXJyZWRcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uT3JSZXF1ZXN0IGBpbmRleGVkRGJgIHRyYW5zYWN0aW9uIG9yIHJlcXVlc3QgdG8gbGlzdGVuXG4gICAqIEByZXR1cm5zIEFuIGBPYnNlcnZhYmxlYCBsaXN0ZW5pbmcgdG8gZXJyb3JzXG4gICAqL1xuICBwcm90ZWN0ZWQgbGlzdGVuRXJyb3IodHJhbnNhY3Rpb25PclJlcXVlc3Q6IElEQlRyYW5zYWN0aW9uIHwgSURCUmVxdWVzdCk6IE9ic2VydmFibGU8bmV2ZXI+IHtcblxuICAgIHJldHVybiBmcm9tRXZlbnQodHJhbnNhY3Rpb25PclJlcXVlc3QsIFwiZXJyb3JcIikucGlwZShcbiAgICAgIC8qIFRocm93IG9uIGVycm9yIHRvIGJlIGFibGUgdG8gY2F0Y2ggZXJyb3JzIGluIFJ4SlMgd2F5LlxuICAgICAgICogSGVyZSBgZXZlbnQudGFyZ2V0YCBtdXN0IGJlIHVzZWQsIGFzIGB0cmFuc2FjdGlvbk9yUmVxdWVzdC5lcnJvcmAgd2lsbCBiZSBgbnVsbGBcbiAgICAgICAqIGlmIHdlIGFyZSBvbiB0aGUgcmVxdWVzdCBhbmQgdGhlIGVycm9yIGlzIG9ubHkgdHJpZ2dlcmVkIGxhdGVyIGJ5IHRoZSB0cmFuc2FjdGlvbiAqL1xuICAgICAgbWVyZ2VNYXAoKGV2ZW50KSA9PiB0aHJvd0Vycm9yKCgpID0+IChldmVudC50YXJnZXQgYXMgSURCVHJhbnNhY3Rpb24gfCBJREJSZXF1ZXN0IHwgbnVsbCk/LmVycm9yKSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0cmFuc2FjdGlvbiBgY29tcGxldGVgIGFuZCBgZXJyb3JgIGV2ZW50c1xuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gdG8gbGlzdGVuXG4gICAqIEByZXR1cm5zIEFuIGBPYnNlcnZhYmxlYCBsaXN0ZW5pbmcgdG8gdHJhbnNhY3Rpb24gYGNvbXBsZXRlYCBhbmQgYGVycm9yYCBldmVudHNcbiAgICovXG4gIHByb3RlY3RlZCBsaXN0ZW5UcmFuc2FjdGlvbkV2ZW50cyh0cmFuc2FjdGlvbjogSURCVHJhbnNhY3Rpb24pOiBPYnNlcnZhYmxlPEV2ZW50PiB7XG5cbiAgICAvKiBMaXN0ZW4gdG8gdGhlIGBjb21wbGV0ZWAgZXZlbnQgKi9cbiAgICBjb25zdCBjb21wbGV0ZSQgPSBmcm9tRXZlbnQodHJhbnNhY3Rpb24sIFwiY29tcGxldGVcIik7XG5cbiAgICAvKiBMaXN0ZW4gdG8gdGhlIGBlcnJvcmAgZXZlbnQgKi9cbiAgICBjb25zdCBlcnJvciQgPSB0aGlzLmxpc3RlbkVycm9yKHRyYW5zYWN0aW9uKTtcblxuICAgIC8qIENob29zZSB0aGUgZmlyc3QgZXZlbnQgdG8gb2NjdXIgKi9cbiAgICByZXR1cm4gcmFjZShbY29tcGxldGUkLCBlcnJvciRdKTtcblxuICB9XG5cbn1cbiJdfQ==
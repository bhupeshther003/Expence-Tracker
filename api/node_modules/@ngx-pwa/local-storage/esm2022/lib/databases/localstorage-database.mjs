import { Injectable, inject } from "@angular/core";
import { Observable, asyncScheduler, of, throwError } from "rxjs";
import { observeOn } from "rxjs/operators";
import { LS_PREFIX } from "../tokens";
import { SerializationError } from "./exceptions";
import * as i0 from "@angular/core";
export class LocalStorageDatabase {
    constructor() {
        /* Prefix if asked, or no prefix otherwise */
        this.prefix = inject(LS_PREFIX) || "";
    }
    /**
     * Number of items in `localStorage`
     */
    get size() {
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(localStorage.length);
    }
    /**
     * Gets an item value in `localStorage`
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`
     */
    get(key) {
        /* Get raw data */
        const unparsedData = localStorage.getItem(this.prefixKey(key));
        let parsedData;
        /* No need to parse if data is `null` or `undefined` */
        if (unparsedData !== null) {
            /* Try to parse */
            try {
                parsedData = JSON.parse(unparsedData);
            }
            catch (error) {
                return throwError(() => error);
            }
        }
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(parsedData);
    }
    /**
     * Store an item in `localStorage`
     * @param key The item's key
     * @param data The item's value
     * @returns A RxJS `Observable` to wait the end of the operation
     */
    set(key, data) {
        let serializedData = null;
        /* Check if data can be serialized */
        const dataPrototype = Object.getPrototypeOf(data);
        if ((typeof data === "object") && (data !== null) && !Array.isArray(data) &&
            !((dataPrototype === Object.prototype) || (dataPrototype === null))) {
            return throwError(() => new SerializationError());
        }
        /* Try to stringify (can fail on circular references) */
        try {
            serializedData = JSON.stringify(data);
        }
        catch (error) {
            return throwError(() => error);
        }
        /* Can fail if storage quota is exceeded */
        try {
            localStorage.setItem(this.prefixKey(key), serializedData);
        }
        catch (error) {
            return throwError(() => error);
        }
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(undefined);
    }
    /**
     * Deletes an item in `localStorage`
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     */
    delete(key) {
        localStorage.removeItem(this.prefixKey(key));
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(undefined);
    }
    /**
     * Deletes all items in `localStorage`
     * @returns A RxJS `Observable` to wait the end of the operation
     */
    clear() {
        localStorage.clear();
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(undefined);
    }
    /**
     * Get all keys in `localStorage`
     * Note the order of the keys may be inconsistent in Firefox
     * @returns A RxJS `Observable` iterating on keys
     */
    keys() {
        /* Create an `Observable` from keys */
        return new Observable((subscriber) => {
            /* Iteretate over all the indexes */
            for (let index = 0; index < localStorage.length; index += 1) {
                /* Cast as we are sure in this case the key is not `null` */
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                subscriber.next(this.getUnprefixedKey(index));
            }
            subscriber.complete();
        }).pipe(
        /* Required to work like other databases which are asynchronous */
        observeOn(asyncScheduler));
    }
    /**
     * Check if a key exists in `localStorage`
     * @param key The item's key
     * @returns A RxJS `Observable` telling if the key exists or not
     */
    has(key) {
        /* Itérate over all indexes in storage */
        for (let index = 0; index < localStorage.length; index += 1) {
            if (key === this.getUnprefixedKey(index)) {
                /* Wrap in a RxJS `Observable` to be consistent with other storages */
                return of(true);
            }
        }
        /* Wrap in a RxJS `Observable` to be consistent with other storages */
        return of(false);
    }
    /**
     * Get an unprefixed key
     * @param index Index of the key
     * @returns The unprefixed key name if exists, `null` otherwise
     */
    getUnprefixedKey(index) {
        /* Get the key in storage: may have a prefix */
        const prefixedKey = localStorage.key(index);
        if (prefixedKey !== null) {
            /* If no prefix, the key is already good, otherwrite strip the prefix */
            return !this.prefix ? prefixedKey : prefixedKey.substring(this.prefix.length);
        }
        return null;
    }
    /**
     * Add the prefix to a key
     * @param key The key name
     * @returns The prefixed key name
     */
    prefixKey(key) {
        return `${this.prefix}${key}`;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: LocalStorageDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: LocalStorageDatabase, providedIn: "root" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: LocalStorageDatabase, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: "root"
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxzdG9yYWdlLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXB3YS9sb2NhbC1zdG9yYWdlL3NyYy9saWIvZGF0YWJhc2VzL2xvY2Fsc3RvcmFnZS1kYXRhYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7QUFNbEQsTUFBTSxPQUFPLG9CQUFvQjtJQU8vQjtRQUVFLDZDQUE2QztRQUM3QyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7SUFFeEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxJQUFJO1FBRU4sc0VBQXNFO1FBQ3RFLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUVqQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEdBQUcsQ0FBQyxHQUFXO1FBRWIsa0JBQWtCO1FBQ2xCLE1BQU0sWUFBWSxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRS9ELElBQUksVUFBbUIsQ0FBQztRQUV4Qix1REFBdUQ7UUFDdkQsSUFBSSxZQUFZLEtBQUssSUFBSSxFQUFFO1lBRXpCLGtCQUFrQjtZQUNsQixJQUFJO2dCQUNGLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFD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SSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUV4QyxzRUFBc0U7Z0JBQ3RFLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBRWpCO1NBRUY7UUFFRCxzRUFBc0U7UUFDdEUsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFbkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxnQkFBZ0IsQ0FBQyxLQUFhO1FBRXRDLCtDQUErQztRQUMvQyxNQUFNLFdBQVcsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTVDLElBQUksV0FBVyxLQUFLLElBQUksRUFBRTtZQUV4Qix3RUFBd0U7WUFDeEUsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBRS9FO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFFZCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLFNBQVMsQ0FBQyxHQUFXO1FBRTdCLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBRWhDLENBQUM7OEdBdE1VLG9CQUFvQjtrSEFBcEIsb0JBQW9CLGNBRm5CLE1BQU07OzJGQUVQLG9CQUFvQjtrQkFIaEMsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgYXN5bmNTY2hlZHVsZXIsIG9mLCB0aHJvd0Vycm9yIH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IG9ic2VydmVPbiB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuaW1wb3J0IHsgTFNfUFJFRklYIH0gZnJvbSBcIi4uL3Rva2Vuc1wiO1xuaW1wb3J0IHsgU2VyaWFsaXphdGlvbkVycm9yIH0gZnJvbSBcIi4vZXhjZXB0aW9uc1wiO1xuaW1wb3J0IHsgTG9jYWxEYXRhYmFzZSB9IGZyb20gXCIuL2xvY2FsLWRhdGFiYXNlXCI7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogXCJyb290XCJcbn0pXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlRGF0YWJhc2UgaW1wbGVtZW50cyBMb2NhbERhdGFiYXNlIHtcblxuICAvKipcbiAgICogT3B0aW9uYWwgdXNlciBwcmVmaXggdG8gYXZvaWQgY29sbGlzaW9uIGZvciBtdWx0aXBsZSBhcHBzIG9uIHRoZSBzYW1lIHN1YmRvbWFpblxuICAgKi9cbiAgcmVhZG9ubHkgcHJlZml4OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAvKiBQcmVmaXggaWYgYXNrZWQsIG9yIG5vIHByZWZpeCBvdGhlcndpc2UgKi9cbiAgICB0aGlzLnByZWZpeCA9IGluamVjdChMU19QUkVGSVgpIHx8IFwiXCI7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgaXRlbXMgaW4gYGxvY2FsU3RvcmFnZWBcbiAgICovXG4gIGdldCBzaXplKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG5cbiAgICAvKiBXcmFwIGluIGEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gYmUgY29uc2lzdGVudCB3aXRoIG90aGVyIHN0b3JhZ2VzICovXG4gICAgcmV0dXJuIG9mKGxvY2FsU3RvcmFnZS5sZW5ndGgpO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBpdGVtIHZhbHVlIGluIGBsb2NhbFN0b3JhZ2VgXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgVGhlIGl0ZW0ncyB2YWx1ZSBpZiB0aGUga2V5IGV4aXN0cywgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGEgUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICovXG4gIGdldChrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5rbm93bj4ge1xuXG4gICAgLyogR2V0IHJhdyBkYXRhICovXG4gICAgY29uc3QgdW5wYXJzZWREYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5wcmVmaXhLZXkoa2V5KSk7XG5cbiAgICBsZXQgcGFyc2VkRGF0YTogdW5rbm93bjtcblxuICAgIC8qIE5vIG5lZWQgdG8gcGFyc2UgaWYgZGF0YSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgKi9cbiAgICBpZiAodW5wYXJzZWREYXRhICE9PSBudWxsKSB7XG5cbiAgICAgIC8qIFRyeSB0byBwYXJzZSAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UodW5wYXJzZWREYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCgpID0+IGVycm9yIGFzIFN5bnRheEVycm9yKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8qIFdyYXAgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYCB0byBiZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgc3RvcmFnZXMgKi9cbiAgICByZXR1cm4gb2YocGFyc2VkRGF0YSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSBhbiBpdGVtIGluIGBsb2NhbFN0b3JhZ2VgXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIGRhdGEgVGhlIGl0ZW0ncyB2YWx1ZVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBzZXQoa2V5OiBzdHJpbmcsIGRhdGE6IHVua25vd24pOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgbGV0IHNlcmlhbGl6ZWREYXRhOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAgIC8qIENoZWNrIGlmIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgKi9cbiAgICBjb25zdCBkYXRhUHJvdG90eXBlOiB1bmtub3duID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGRhdGEpO1xuICAgIGlmICgodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpICYmIChkYXRhICE9PSBudWxsKSAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSAmJlxuICAgICAgISgoZGF0YVByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSkgfHwgKGRhdGFQcm90b3R5cGUgPT09IG51bGwpKSkge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IoKCkgPT4gbmV3IFNlcmlhbGl6YXRpb25FcnJvcigpKTtcbiAgICB9XG5cbiAgICAvKiBUcnkgdG8gc3RyaW5naWZ5IChjYW4gZmFpbCBvbiBjaXJjdWxhciByZWZlcmVuY2VzKSAqL1xuICAgIHRyeSB7XG4gICAgICBzZXJpYWxpemVkRGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcigoKSA9PiBlcnJvciBhcyBUeXBlRXJyb3IpO1xuICAgIH1cblxuICAgIC8qIENhbiBmYWlsIGlmIHN0b3JhZ2UgcXVvdGEgaXMgZXhjZWVkZWQgKi9cbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5wcmVmaXhLZXkoa2V5KSwgc2VyaWFsaXplZERhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcigoKSA9PiBlcnJvciBhcyBET01FeGNlcHRpb24pO1xuICAgIH1cblxuICAgIC8qIFdyYXAgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYCB0byBiZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgc3RvcmFnZXMgKi9cbiAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gaXRlbSBpbiBgbG9jYWxTdG9yYWdlYFxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnByZWZpeEtleShrZXkpKTtcblxuICAgIC8qIFdyYXAgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYCB0byBiZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgc3RvcmFnZXMgKi9cbiAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGl0ZW1zIGluIGBsb2NhbFN0b3JhZ2VgXG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGNsZWFyKCk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcblxuICAgIC8qIFdyYXAgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYCB0byBiZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgc3RvcmFnZXMgKi9cbiAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwga2V5cyBpbiBgbG9jYWxTdG9yYWdlYFxuICAgKiBOb3RlIHRoZSBvcmRlciBvZiB0aGUga2V5cyBtYXkgYmUgaW5jb25zaXN0ZW50IGluIEZpcmVmb3hcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCBpdGVyYXRpbmcgb24ga2V5c1xuICAgKi9cbiAga2V5cygpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXG4gICAgLyogQ3JlYXRlIGFuIGBPYnNlcnZhYmxlYCBmcm9tIGtleXMgKi9cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGU8c3RyaW5nPigoc3Vic2NyaWJlcikgPT4ge1xuXG4gICAgICAvKiBJdGVyZXRhdGUgb3ZlciBhbGwgdGhlIGluZGV4ZXMgKi9cbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpbmRleCArPSAxKSB7XG5cbiAgICAgICAgLyogQ2FzdCBhcyB3ZSBhcmUgc3VyZSBpbiB0aGlzIGNhc2UgdGhlIGtleSBpcyBub3QgYG51bGxgICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLmdldFVucHJlZml4ZWRLZXkoaW5kZXgpISk7XG5cbiAgICAgIH1cblxuICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuXG4gICAgfSkucGlwZShcbiAgICAgIC8qIFJlcXVpcmVkIHRvIHdvcmsgbGlrZSBvdGhlciBkYXRhYmFzZXMgd2hpY2ggYXJlIGFzeW5jaHJvbm91cyAqL1xuICAgICAgb2JzZXJ2ZU9uKGFzeW5jU2NoZWR1bGVyKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXkgZXhpc3RzIGluIGBsb2NhbFN0b3JhZ2VgXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0ZWxsaW5nIGlmIHRoZSBrZXkgZXhpc3RzIG9yIG5vdFxuICAgKi9cbiAgaGFzKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBJdMOpcmF0ZSBvdmVyIGFsbCBpbmRleGVzIGluIHN0b3JhZ2UgKi9cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgICBpZiAoa2V5ID09PSB0aGlzLmdldFVucHJlZml4ZWRLZXkoaW5kZXgpKSB7XG5cbiAgICAgICAgLyogV3JhcCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBzdG9yYWdlcyAqL1xuICAgICAgICByZXR1cm4gb2YodHJ1ZSk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8qIFdyYXAgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYCB0byBiZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgc3RvcmFnZXMgKi9cbiAgICByZXR1cm4gb2YoZmFsc2UpO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIHVucHJlZml4ZWQga2V5XG4gICAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUga2V5XG4gICAqIEByZXR1cm5zIFRoZSB1bnByZWZpeGVkIGtleSBuYW1lIGlmIGV4aXN0cywgYG51bGxgIG90aGVyd2lzZVxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucHJlZml4ZWRLZXkoaW5kZXg6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuXG4gICAgLyogR2V0IHRoZSBrZXkgaW4gc3RvcmFnZTogbWF5IGhhdmUgYSBwcmVmaXggKi9cbiAgICBjb25zdCBwcmVmaXhlZEtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaW5kZXgpO1xuXG4gICAgaWYgKHByZWZpeGVkS2V5ICE9PSBudWxsKSB7XG5cbiAgICAgIC8qIElmIG5vIHByZWZpeCwgdGhlIGtleSBpcyBhbHJlYWR5IGdvb2QsIG90aGVyd3JpdGUgc3RyaXAgdGhlIHByZWZpeCAqL1xuICAgICAgcmV0dXJuICF0aGlzLnByZWZpeCA/IHByZWZpeGVkS2V5IDogcHJlZml4ZWRLZXkuc3Vic3RyaW5nKHRoaXMucHJlZml4Lmxlbmd0aCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcblxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgcHJlZml4IHRvIGEga2V5XG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBuYW1lXG4gICAqIEByZXR1cm5zIFRoZSBwcmVmaXhlZCBrZXkgbmFtZVxuICAgKi9cbiAgcHJvdGVjdGVkIHByZWZpeEtleShrZXk6IHN0cmluZyk6IHN0cmluZyB7XG5cbiAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9JHtrZXl9YDtcblxuICB9XG5cbn1cbiJdfQ==
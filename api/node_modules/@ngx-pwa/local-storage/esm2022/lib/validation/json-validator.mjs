import { Injectable } from "@angular/core";
import * as i0 from "@angular/core";
export class JSONValidator {
    /**
     * Validate a JSON data against a Jsubset of the JSON Schema standard.
     * Types are enforced to validate everything: each schema must
     * @param data JSON data to validate
     * @param schema Subset of JSON Schema. Must have a `type`.
     * @returns If data is valid: `true`, if it is invalid: `false`
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}
     */
    validate(data, schema) {
        switch (schema.type) {
            case "string":
                return this.validateString(data, schema);
            case "number":
            case "integer":
                return this.validateNumber(data, schema);
            case "boolean":
                return this.validateBoolean(data, schema);
            case "array":
                return this.validateArray(data, schema);
            case "object":
                return this.validateObject(data, schema);
        }
    }
    /**
     * Validate a string
     * @param data Data to validate
     * @param schema Schema describing the string
     * @returns If data is valid: `true`, if it is invalid: `false`
     */
    validateString(data, schema) {
        if (typeof data !== "string") {
            return false;
        }
        if (!this.validateConst(data, schema)) {
            return false;
        }
        if (!this.validateEnum(data, schema)) {
            return false;
        }
        if ((schema.maxLength !== undefined) && (data.length > schema.maxLength)) {
            return false;
        }
        if ((schema.minLength !== undefined) && (data.length < schema.minLength)) {
            return false;
        }
        if (schema.pattern) {
            let regularExpression = null;
            try {
                regularExpression = new RegExp(schema.pattern);
            }
            catch {
                // Nothing to do
            }
            if (regularExpression && !regularExpression.test(data)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Validate a number or an integer
     * @param data Data to validate
     * @param schema Schema describing the number or integer
     * @returns If data is valid: `true`, if it is invalid: `false`
     */
    validateNumber(data, schema) {
        if (typeof data !== "number") {
            return false;
        }
        if ((schema.type === "integer") && !Number.isInteger(data)) {
            return false;
        }
        if (!this.validateConst(data, schema)) {
            return false;
        }
        if (!this.validateEnum(data, schema)) {
            return false;
        }
        /* Test is done this way to not divide by 0 */
        if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {
            return false;
        }
        if ((schema.maximum !== undefined) && (data > schema.maximum)) {
            return false;
        }
        if ((schema.exclusiveMaximum !== undefined) && (data >= schema.exclusiveMaximum)) {
            return false;
        }
        if ((schema.minimum !== undefined) && (data < schema.minimum)) {
            return false;
        }
        if ((schema.exclusiveMinimum !== undefined) && (data <= schema.exclusiveMinimum)) {
            return false;
        }
        return true;
    }
    /**
     * Validate a boolean
     * @param data Data to validate
     * @param schema Schema describing the boolean
     * @returns If data is valid: `true`, if it is invalid: `false`
     */
    validateBoolean(data, schema) {
        if (typeof data !== "boolean") {
            return false;
        }
        if (!this.validateConst(data, schema)) {
            return false;
        }
        return true;
    }
    /**
     * Validate an array
     * @param data Data to validate
     * @param schema Schema describing the array
     * @returns If data is valid: `true`, if it is invalid: `false`
     */
    validateArray(data, schema) {
        if (!Array.isArray(data)) {
            return false;
        }
        if ((schema.maxItems !== undefined) && (data.length > schema.maxItems)) {
            return false;
        }
        if ((schema.minItems !== undefined) && (data.length < schema.minItems)) {
            return false;
        }
        if (schema.uniqueItems) {
            /* Create a set to eliminate values with multiple occurences */
            const dataSet = new Set(data);
            if (data.length !== dataSet.size) {
                return false;
            }
        }
        /* Specific test for tuples */
        if (Array.isArray(schema.items) || schema.items === undefined) {
            // TODO: cast should not be needed here
            return this.validateTuple(data, schema.items);
        }
        /* Validate all the values in array */
        for (const value of data) {
            // TODO: remove when TypeScript 4.1 is available
            // (currently the narrowed type from `Array.isArray()` is lost on readonly arrays)
            if (!this.validate(value, schema.items)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Validate a tuple (array with fixed length and multiple types)
     * @param data Data to validate
     * @param schemas Schemas describing the tuple
     * @returns If data is valid: `true`, if it is invalid: `false`
     */
    validateTuple(data, schemas) {
        const lengthToCheck = schemas ? schemas.length : 0;
        /* Tuples have a fixed length */
        if (data.length !== lengthToCheck) {
            return false;
        }
        if (schemas) {
            for (let i = 0; i < schemas.length; i += 1) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                if (!this.validate(data[i], schemas[i])) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Validate an object
     * @param data Data to validate
     * @param schema JSON schema describing the object
     * @returns If data is valid: `true`, if it is invalid: `false`
     */
    validateObject(data, schema) {
        /* Check the type and if not `null` as `null` also have the type `object` in old browsers */
        if ((typeof data !== "object") || (data === null)) {
            return false;
        }
        /* Check if the object doesn't have more properties than expected
         * Equivalent of `additionalProperties: false`
         */
        if (Object.keys(schema.properties).length < Object.keys(data).length) {
            return false;
        }
        /* Validate required properties */
        if (schema.required) {
            for (const requiredProp of schema.required) {
                if (!Object.prototype.hasOwnProperty.call(data, requiredProp)) {
                    return false;
                }
            }
        }
        /* Recursively validate all properties */
        for (const property in schema.properties) {
            /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */
            if (Object.prototype.hasOwnProperty.call(schema.properties, property) && Object.prototype.hasOwnProperty.call(data, property)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                if (!this.validate(data[property], schema.properties[property])) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Validate a constant
     * @param data Data ta validate
     * @param schema JSON schema describing the constant
     * @returns If data is valid: `true`, if it is invalid: `false`
     */
    validateConst(data, schema) {
        if (!schema.const) {
            return true;
        }
        return (data === schema.const);
    }
    /**
     * Validate an enum
     * @param data Data ta validate
     * @param schema JSON schema describing the enum
     * @returns If data is valid: `true`, if it is invalid: `false`
     */
    validateEnum(data, schema) {
        if (!schema.enum) {
            return true;
        }
        /* Cast as the data can be of multiple types, and so TypeScript is lost */
        return (schema.enum.includes(data));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: JSONValidator, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: JSONValidator, providedIn: "root" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.0", ngImport: i0, type: JSONValidator, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: "root"
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi12YWxpZGF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtcHdhL2xvY2FsLXN0b3JhZ2Uvc3JjL2xpYi92YWxpZGF0aW9uL2pzb24tdmFsaWRhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBYzNDLE1BQU0sT0FBTyxhQUFhO0lBRXhCOzs7Ozs7O09BT0c7SUFDSCxRQUFRLENBQUMsSUFBYSxFQUFFLE1BQWtCO1FBRXhDLFFBQVEsTUFBTSxDQUFDLElBQUksRUFBRTtZQUVuQixLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztZQUMzQyxLQUFLLFFBQVEsQ0FBQztZQUNkLEtBQUssU0FBUztnQkFDWixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQzNDLEtBQUssU0FBUztnQkFDWixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQzVDLEtBQUssT0FBTztnQkFDVixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQzFDLEtBQUssUUFBUTtnQkFDWCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBRTVDO0lBRUgsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sY0FBYyxDQUFDLElBQWEsRUFBRSxNQUF3QjtRQUU5RCxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUM1QixPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFO1lBQ3JDLE9BQU8sS0FBSyxD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LElBQUksQ0FBQztTQUNiO1FBRUQsMEVBQTBFO1FBQzFFLE9BQU8sQ0FBRSxNQUFNLENBQUMsSUFBa0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUVyRCxDQUFDOzhHQWhVVSxhQUFhO2tIQUFiLGFBQWEsY0FGWixNQUFNOzsyRkFFUCxhQUFhO2tCQUh6QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHtcbiAgSlNPTlNjaGVtYSxcbiAgSlNPTlNjaGVtYUFycmF5LFxuICBKU09OU2NoZW1hQm9vbGVhbixcbiAgSlNPTlNjaGVtYUludGVnZXIsIEpTT05TY2hlbWFOdW1iZXIsXG4gIEpTT05TY2hlbWFPYmplY3QsXG4gIEpTT05TY2hlbWFTdHJpbmcsXG4gIEpTT05TY2hlbWFUdXBsZVxufSBmcm9tIFwiLi9qc29uLXNjaGVtYVwiO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46IFwicm9vdFwiXG59KVxuZXhwb3J0IGNsYXNzIEpTT05WYWxpZGF0b3Ige1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIEpTT04gZGF0YSBhZ2FpbnN0IGEgSnN1YnNldCBvZiB0aGUgSlNPTiBTY2hlbWEgc3RhbmRhcmQuXG4gICAqIFR5cGVzIGFyZSBlbmZvcmNlZCB0byB2YWxpZGF0ZSBldmVyeXRoaW5nOiBlYWNoIHNjaGVtYSBtdXN0XG4gICAqIEBwYXJhbSBkYXRhIEpTT04gZGF0YSB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0gc2NoZW1hIFN1YnNldCBvZiBKU09OIFNjaGVtYS4gTXVzdCBoYXZlIGEgYHR5cGVgLlxuICAgKiBAcmV0dXJucyBJZiBkYXRhIGlzIHZhbGlkOiBgdHJ1ZWAsIGlmIGl0IGlzIGludmFsaWQ6IGBmYWxzZWBcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9WQUxJREFUSU9OLm1kfVxuICAgKi9cbiAgdmFsaWRhdGUoZGF0YTogdW5rbm93biwgc2NoZW1hOiBKU09OU2NoZW1hKTogYm9vbGVhbiB7XG5cbiAgICBzd2l0Y2ggKHNjaGVtYS50eXBlKSB7XG5cbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTdHJpbmcoZGF0YSwgc2NoZW1hKTtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTnVtYmVyKGRhdGEsIHNjaGVtYSk7XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUJvb2xlYW4oZGF0YSwgc2NoZW1hKTtcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUFycmF5KGRhdGEsIHNjaGVtYSk7XG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlT2JqZWN0KGRhdGEsIHNjaGVtYSk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHN0cmluZ1xuICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBzY2hlbWEgU2NoZW1hIGRlc2NyaWJpbmcgdGhlIHN0cmluZ1xuICAgKiBAcmV0dXJucyBJZiBkYXRhIGlzIHZhbGlkOiBgdHJ1ZWAsIGlmIGl0IGlzIGludmFsaWQ6IGBmYWxzZWBcbiAgICovXG4gIHByb3RlY3RlZCB2YWxpZGF0ZVN0cmluZyhkYXRhOiB1bmtub3duLCBzY2hlbWE6IEpTT05TY2hlbWFTdHJpbmcpOiBib29sZWFuIHtcblxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUNvbnN0KGRhdGEsIHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVFbnVtKGRhdGEsIHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoKHNjaGVtYS5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCkgJiYgKGRhdGEubGVuZ3RoID4gc2NoZW1hLm1heExlbmd0aCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoKHNjaGVtYS5taW5MZW5ndGggIT09IHVuZGVmaW5lZCkgJiYgKGRhdGEubGVuZ3RoIDwgc2NoZW1hLm1pbkxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLnBhdHRlcm4pIHtcblxuICAgICAgbGV0IHJlZ3VsYXJFeHByZXNzaW9uOiBSZWdFeHAgfCBudWxsID0gbnVsbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVndWxhckV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKHNjaGVtYS5wYXR0ZXJuKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvXG4gICAgICB9XG5cbiAgICAgIGlmIChyZWd1bGFyRXhwcmVzc2lvbiAmJiAhcmVndWxhckV4cHJlc3Npb24udGVzdChkYXRhKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgbnVtYmVyIG9yIGFuIGludGVnZXJcbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0gc2NoZW1hIFNjaGVtYSBkZXNjcmliaW5nIHRoZSBudW1iZXIgb3IgaW50ZWdlclxuICAgKiBAcmV0dXJucyBJZiBkYXRhIGlzIHZhbGlkOiBgdHJ1ZWAsIGlmIGl0IGlzIGludmFsaWQ6IGBmYWxzZWBcbiAgICovXG4gIHByb3RlY3RlZCB2YWxpZGF0ZU51bWJlcihkYXRhOiB1bmtub3duLCBzY2hlbWE6IEpTT05TY2hlbWFOdW1iZXIgfCBKU09OU2NoZW1hSW50ZWdlcik6IGJvb2xlYW4ge1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKChzY2hlbWEudHlwZSA9PT0gXCJpbnRlZ2VyXCIpICYmICFOdW1iZXIuaXNJbnRlZ2VyKGRhdGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlQ29uc3QoZGF0YSwgc2NoZW1hKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy52YWxpZGF0ZUVudW0oZGF0YSwgc2NoZW1hKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qIFRlc3QgaXMgZG9uZSB0aGlzIHdheSB0byBub3QgZGl2aWRlIGJ5IDAgKi9cbiAgICBpZiAoc2NoZW1hLm11bHRpcGxlT2YgJiYgIU51bWJlci5pc0ludGVnZXIoZGF0YSAvIHNjaGVtYS5tdWx0aXBsZU9mKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgoc2NoZW1hLm1heGltdW0gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGEgPiBzY2hlbWEubWF4aW11bSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtICE9PSB1bmRlZmluZWQpICYmIChkYXRhID49IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgaWYgKChzY2hlbWEubWluaW11bSAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YSA8IHNjaGVtYS5taW5pbXVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgaWYgKChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YSA8PSBzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgYm9vbGVhblxuICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBzY2hlbWEgU2NoZW1hIGRlc2NyaWJpbmcgdGhlIGJvb2xlYW5cbiAgICogQHJldHVybnMgSWYgZGF0YSBpcyB2YWxpZDogYHRydWVgLCBpZiBpdCBpcyBpbnZhbGlkOiBgZmFsc2VgXG4gICAqL1xuICBwcm90ZWN0ZWQgdmFsaWRhdGVCb29sZWFuKGRhdGE6IHVua25vd24sIHNjaGVtYTogSlNPTlNjaGVtYUJvb2xlYW4pOiBib29sZWFuIHtcblxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVDb25zdChkYXRhLCBzY2hlbWEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbiBhcnJheVxuICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBzY2hlbWEgU2NoZW1hIGRlc2NyaWJpbmcgdGhlIGFycmF5XG4gICAqIEByZXR1cm5zIElmIGRhdGEgaXMgdmFsaWQ6IGB0cnVlYCwgaWYgaXQgaXMgaW52YWxpZDogYGZhbHNlYFxuICAgKi9cbiAgcHJvdGVjdGVkIHZhbGlkYXRlQXJyYXkoZGF0YTogdW5rbm93biwgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXkgfCBKU09OU2NoZW1hVHVwbGUpOiBib29sZWFuIHtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgoc2NoZW1hLm1heEl0ZW1zICE9PSB1bmRlZmluZWQpICYmIChkYXRhLmxlbmd0aCA+IHNjaGVtYS5tYXhJdGVtcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoKHNjaGVtYS5taW5JdGVtcyAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YS5sZW5ndGggPCBzY2hlbWEubWluSXRlbXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS51bmlxdWVJdGVtcykge1xuXG4gICAgICAvKiBDcmVhdGUgYSBzZXQgdG8gZWxpbWluYXRlIHZhbHVlcyB3aXRoIG11bHRpcGxlIG9jY3VyZW5jZXMgKi9cbiAgICAgIGNvbnN0IGRhdGFTZXQgPSBuZXcgU2V0KGRhdGEpO1xuXG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT09IGRhdGFTZXQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiBTcGVjaWZpYyB0ZXN0IGZvciB0dXBsZXMgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpIHx8IHNjaGVtYS5pdGVtcyA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vIFRPRE86IGNhc3Qgc2hvdWxkIG5vdCBiZSBuZWVkZWQgaGVyZVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVUdXBsZShkYXRhLCBzY2hlbWEuaXRlbXMgYXMgSlNPTlNjaGVtYVtdIHwgdW5kZWZpbmVkKTtcblxuICAgIH1cblxuICAgIC8qIFZhbGlkYXRlIGFsbCB0aGUgdmFsdWVzIGluIGFycmF5ICovXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkYXRhKSB7XG5cbiAgICAgIC8vIFRPRE86IHJlbW92ZSB3aGVuIFR5cGVTY3JpcHQgNC4xIGlzIGF2YWlsYWJsZVxuICAgICAgLy8gKGN1cnJlbnRseSB0aGUgbmFycm93ZWQgdHlwZSBmcm9tIGBBcnJheS5pc0FycmF5KClgIGlzIGxvc3Qgb24gcmVhZG9ubHkgYXJyYXlzKVxuICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlKHZhbHVlLCBzY2hlbWEuaXRlbXMgYXMgSlNPTlNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHR1cGxlIChhcnJheSB3aXRoIGZpeGVkIGxlbmd0aCBhbmQgbXVsdGlwbGUgdHlwZXMpXG4gICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gdmFsaWRhdGVcbiAgICogQHBhcmFtIHNjaGVtYXMgU2NoZW1hcyBkZXNjcmliaW5nIHRoZSB0dXBsZVxuICAgKiBAcmV0dXJucyBJZiBkYXRhIGlzIHZhbGlkOiBgdHJ1ZWAsIGlmIGl0IGlzIGludmFsaWQ6IGBmYWxzZWBcbiAgICovXG4gIHByb3RlY3RlZCB2YWxpZGF0ZVR1cGxlKGRhdGE6IHVua25vd25bXSwgc2NoZW1hczogSlNPTlNjaGVtYVtdIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG5cbiAgICBjb25zdCBsZW5ndGhUb0NoZWNrID0gc2NoZW1hcyA/IHNjaGVtYXMubGVuZ3RoIDogMDtcblxuICAgIC8qIFR1cGxlcyBoYXZlIGEgZml4ZWQgbGVuZ3RoICovXG4gICAgaWYgKGRhdGEubGVuZ3RoICE9PSBsZW5ndGhUb0NoZWNrKSB7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGlmIChzY2hlbWFzKSB7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hcy5sZW5ndGg7IGkgKz0gMSkge1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZShkYXRhW2ldLCBzY2hlbWFzW2ldISkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbiBvYmplY3RcbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0gc2NoZW1hIEpTT04gc2NoZW1hIGRlc2NyaWJpbmcgdGhlIG9iamVjdFxuICAgKiBAcmV0dXJucyBJZiBkYXRhIGlzIHZhbGlkOiBgdHJ1ZWAsIGlmIGl0IGlzIGludmFsaWQ6IGBmYWxzZWBcbiAgICovXG4gIHByb3RlY3RlZCB2YWxpZGF0ZU9iamVjdChkYXRhOiB1bmtub3duLCBzY2hlbWE6IEpTT05TY2hlbWFPYmplY3QpOiBib29sZWFuIHtcblxuICAgIC8qIENoZWNrIHRoZSB0eXBlIGFuZCBpZiBub3QgYG51bGxgIGFzIGBudWxsYCBhbHNvIGhhdmUgdGhlIHR5cGUgYG9iamVjdGAgaW4gb2xkIGJyb3dzZXJzICovXG4gICAgaWYgKCh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikgfHwgKGRhdGEgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyogQ2hlY2sgaWYgdGhlIG9iamVjdCBkb2Vzbid0IGhhdmUgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gZXhwZWN0ZWRcbiAgICAgKiBFcXVpdmFsZW50IG9mIGBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VgXG4gICAgICovXG4gICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGggPCBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBWYWxpZGF0ZSByZXF1aXJlZCBwcm9wZXJ0aWVzICovXG4gICAgaWYgKHNjaGVtYS5yZXF1aXJlZCkge1xuXG4gICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkUHJvcCBvZiBzY2hlbWEucmVxdWlyZWQpIHtcblxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCByZXF1aXJlZFByb3ApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8qIFJlY3Vyc2l2ZWx5IHZhbGlkYXRlIGFsbCBwcm9wZXJ0aWVzICovXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuXG4gICAgICAvKiBGaWx0ZXIgdG8ga2VlcCBvbmx5IHJlYWwgcHJvcGVydGllcyAobm8gaW50ZXJuYWwgSlMgc3R1ZmYpIGFuZCBjaGVjayBpZiB0aGUgZGF0YSBoYXMgdGhlIHByb3BlcnR5IHRvbyAqL1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEucHJvcGVydGllcywgcHJvcGVydHkpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBwcm9wZXJ0eSkpIHtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGUoKGRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW3Byb3BlcnR5XSwgc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHldISkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIGNvbnN0YW50XG4gICAqIEBwYXJhbSBkYXRhIERhdGEgdGEgdmFsaWRhdGVcbiAgICogQHBhcmFtIHNjaGVtYSBKU09OIHNjaGVtYSBkZXNjcmliaW5nIHRoZSBjb25zdGFudFxuICAgKiBAcmV0dXJucyBJZiBkYXRhIGlzIHZhbGlkOiBgdHJ1ZWAsIGlmIGl0IGlzIGludmFsaWQ6IGBmYWxzZWBcbiAgICovXG4gIHByb3RlY3RlZCB2YWxpZGF0ZUNvbnN0KGRhdGE6IHVua25vd24sIHNjaGVtYTogSlNPTlNjaGVtYUJvb2xlYW4gfCBKU09OU2NoZW1hSW50ZWdlciB8IEpTT05TY2hlbWFOdW1iZXIgfCBKU09OU2NoZW1hU3RyaW5nKTogYm9vbGVhbiB7XG5cbiAgICBpZiAoIXNjaGVtYS5jb25zdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIChkYXRhID09PSBzY2hlbWEuY29uc3QpO1xuXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYW4gZW51bVxuICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRhIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBzY2hlbWEgSlNPTiBzY2hlbWEgZGVzY3JpYmluZyB0aGUgZW51bVxuICAgKiBAcmV0dXJucyBJZiBkYXRhIGlzIHZhbGlkOiBgdHJ1ZWAsIGlmIGl0IGlzIGludmFsaWQ6IGBmYWxzZWBcbiAgICovXG4gIHByb3RlY3RlZCB2YWxpZGF0ZUVudW0oZGF0YTogdW5rbm93biwgc2NoZW1hOiBKU09OU2NoZW1hSW50ZWdlciB8IEpTT05TY2hlbWFOdW1iZXIgfCBKU09OU2NoZW1hU3RyaW5nKTogYm9vbGVhbiB7XG5cbiAgICBpZiAoIXNjaGVtYS5lbnVtKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBDYXN0IGFzIHRoZSBkYXRhIGNhbiBiZSBvZiBtdWx0aXBsZSB0eXBlcywgYW5kIHNvIFR5cGVTY3JpcHQgaXMgbG9zdCAqL1xuICAgIHJldHVybiAoKHNjaGVtYS5lbnVtIGFzIHVua25vd25bXSkuaW5jbHVkZXMoZGF0YSkpO1xuXG4gIH1cblxufVxuIl19